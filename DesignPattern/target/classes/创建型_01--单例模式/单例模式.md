### 定义

>+ 背景：
>	+ 高并发下充分发挥和挖掘缓存的潜力，可以说，缓存是高并发系统的银弹，性能不够，缓存来凑；
>	+ 互联网常见的缓存体系：
>		+ 客户端缓存（浏览器端）
>		+ 本地缓存（堆缓存，堆外缓存，磁盘缓存）
>		+ 分布式缓存集群（Redis)等
>	+ 今天我们聚焦本地缓存上，结合单例模式的Google和guava cache缓存组件，打造高并发，线程安全的本地缓存；
>+ 单例模式定义：【Singleton pattern】
>	+ 保证一个类，仅有**一个实例**，并提供**一个**访问它的**全局访问点**。
>+ 特点：
>	+ 把创建实例的权限对外屏蔽了，只有它自己可以使用，而为了让别人能访问它的实例，它专门提供了一个static方法（也就是概念里的全局访问点），用于返回自己的实例；
>	+ 职责概括：
>		+ 私有构造函数；确保类的对象不能从外部创建，只能被它自己创建；
>		+ 静态类属性，类型为它自身；通过静态属性，从语法角度确保这个类的对象，在JVM中只存在一个对象；
>		+ 静态getInstance()方法，返回类型为它自身：这个静态方法，就是这个类的唯一一个全局访问点，通过这个静态方法，单例客户方可以获取单例服务的唯一一个对象；
>+ 使用场景：
>	+ 当某个类的对象，在系统中是独一无二的，只可以存在一个对象时，就需要使用单例模式；
>	+ 常见有缓存管理器、线程池、**数据库连接**、日志管理器、配置参数、驱动程序等
>	+ 今天我们是本地缓存管理器；
>
>

### 实操

#### 提前实例化（饿汉模式）

+ 提前多少，愿望到底有多强烈呢，通常是在类加载的时候，不同的实现方式，稍有不同，只要确保在客户需要前，已经完成对象初始化；
+ 优点：对象提前初始化，无需考虑线程安全问题，代码比较简洁。
+ 缺点：不管客户方是否使用，提前创建好对象，可能会有一定的资源浪费，但是因为本身是单例，所以浪费的资源往往有限，常常忽略不计；
+ 所以提前实例化，一般是首选方案；

>+ 属性初始化 **【推荐方案】**
>+ 静态代码块初始化
>
>

#### 延迟实例化（懒汉模式）

>+ 非线程安全【常见方案】
>+ 线程安全，低效
>+ 线程安全，双重检测，高效**【推荐方案】**
>+ 线程安全，双重检测，可重入锁，高效
>+ 线程安全，静态内部类
>
>